 /*********************************************************
 * Linear Algebra Module
 * Rev: 10/24/2013,  Juan C. Cockburn  (jcck@ieee.org)
 *********************************************************/

#include "linalg.h"
#include <math.h>

/* Allocate memory space for matrix, all at once */
MatElement **matrix_alloc(int nr, int nc) {
  int i;
  MatElement *ptr;
  MatElement **A;

  A = malloc( nr * sizeof(MatElement *));    /* array of ptrs   */
  ptr = calloc( nr*nc, sizeof(MatElement) ); /* matrix elements */
  for (i=0; i<nr; i++)             /* set row pointers properly */
    A[i] = ptr + nc*i;
  return A;
}

/* Allocate memory space for vector, all at once */
VectorElement *vector_alloc(int size){

	/* Declare pointer variable to vector */
	VectorElement *v;

	/* Allocate the memory */
	v=malloc(size * sizeof(VectorElement));

	/* Return pointer to the allocated vector */
	return v;
}

/* Release memory used by matrix */
void matrix_free(MatElement **A) {
  free(A[0]);
  free(A);
}

/* Release memory used by the vector */
void vector_free(VectorElement *p){
	free(p);
}

/* Print matrix elements */
void matrix_print(MatElement **A, char * format, int nr, int nc) {
	int i,j;
	for (i=0; i<nr; i++) {
		for (j=0; j<nc; j++){
			fprintf(stdout,format, A[i][j]);
		}
		/* Print out a pipe character as well as the value in the
		   "Solution" vector */
		fprintf(stdout," | %g\n", A[i][nc]);
	}
}

/* Print vector elements */
void vector_print(VectorElement *v, char * format, int size){
	int i;
	for(i=0;i<size;i++){
		fprintf(stdout,format,v[i]);
	}
	fprintf(stdout,"\n");
}

/* Initialize the values in the permutation vector from values 1 -> size */
void perm_vector_initialize(VectorElement *v, int size){

	/* Declare counter */
	int i;

	/* Set values of vector from 1 -> size */
	for(i=0;i<size;i++){
		v[i]=(i+1);
	}

}

/* Create and Identity Matrix */
MatElement **matrix_identity(int n) {
  int i;
  MatElement **A=matrix_alloc(n, n);
  for (i=0; i<n; ++i)
    A[i][i] = (MatElement) 1;
  return A;
}

int linalg_LU_decomp(MatElement **A, VectorElement *p, int dim){

	/* Declare variables */
	int k,row,col,pivotCounter, pivotIndex, pivotSwapCounter;
	double pivot, maxPivot;

	/* iterate once for every row of the matrix */
	for(k=0;k<dim;k++){

		/* Initially set pivotIndex to k, will stay here unless changed */
		pivotIndex=k;
		maxPivot=A[k][k];
		for(pivotCounter=k;pivotCounter<dim;pivotCounter++){

			/* Set pivot to value at kth row, in the set column */
			pivot=A[pivotCounter][k];
			if(fabs(pivot)>fabs(maxPivot)){
				/* Determine the largest value of pivot */
				maxPivot=pivot;

				/* keep track of row of largest pivot */
				pivotIndex=pivotCounter;
			}
		}

		/* The final pivot is equal to the largest value */
		pivot=maxPivot;

		matrix_print(A," %g ", dim, dim);

		/* Only perform swap operations if necessary. I.E.
		   the iteration row is not equal to the row of largest index */
		if(k!=pivotIndex){
			fprintf(stdout,"swaps need to be made between %d and %d\n",k,pivotIndex);

			/* swap elements in rows k and pivot index */
			for(pivotSwapCounter=0;pivotSwapCounter<dim+1;pivotSwapCounter++){

				double temp;
				temp=A[k][pivotSwapCounter];
				A[k][pivotSwapCounter]=A[pivotIndex][pivotSwapCounter];
				A[pivotIndex][pivotSwapCounter]=temp;

			}

			/* Swap the kth and pivotIndex(th) values of the perm vector */
			int tempVectorValue;
			tempVectorValue=p[k];
			p[k]=p[pivotIndex];
			p[pivotIndex]=tempVectorValue;
		}

		vector_print(p," %d ", dim);

		fprintf(stdout, "Pivot set to: %g\n", pivot);

		/* Set the in-place "pivot factor" */
		for(row=k+1;row<dim;row++){
			A[row][k]=A[row][k]/pivot;
		}

		/* Go through each row and perform factor based operations */
		for(row=k+1;row<dim;row++){

			for(col=k+1;col<dim+1;col++){
				A[row][col]=A[row][col] - A[row][k] * A[k][col];
			}

		}

		matrix_print(A," %g ", dim, dim);

	}

	return 0;


}
/* Implements the in place Gaussian Elimination process with
 * partial pivoting. It should take as input arguments the
 * matrix A and return the results in the overwritten matrix A
 * that encodes the lower part of L and U matrices and the
 * permutaion vector p that defines the permutation matrix P
 */

int linalg_LU_solve(MatElement **A, MatElement **p, MatElement **b, MatElement **x){

	fprintf(stdout, "solve called\n");
	return 0;
}
/* Finds the solution to the system Ax=b given packed LU matrix
 * obtained by the Elimination step in decomp. Should take as input
 * arguments the overwritten matrix A (generated by linalg_LU_decomp),
 * the pivot vector p, the right hand side vector b, and "return"
 * the solution in vector x.
 */

void print_plu(MatElement **A, MatElement **p){

	fprintf(stdout, "print called\n");

}
/* unpack the matrices L, U, and P, and print them as well */
